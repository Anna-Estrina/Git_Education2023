# Работа с **Git**

![Logo](Image\git-logo-png-transparent.png)

## 1. Проверка наличия установленного **Git**
В терминале выполнить команду `git --version`.
Если Git установлен, появится сообщение с информацией о версии программы, иначе будет сообщение об ошибке.

## 2. Установка **Git**
Загружаем последнюю версию Git с [сайта](https://git-scm.com/downloads).
Устанавливаем с настройками по умолчанию.

## 3. Установка и настройка  **Visual Studio Code**

_Visual Studio Code_ - визуальный редактор исходного кода для многих языков программирования. VS Code - не единственный, но один из самых популярных редакторов. Именно в нём пишутся все команды Git.

Загружаем последнюю версию VS Code c [сайта](https://code.visualstudio.com/).
Устанавливаем настройки по умолчанию.

Для удобства можно установить русский язык. Для этого необходимо скачать доступное расширение. В магазине расширений (на панели слева нижний значок) в строке поиска набираем **Russian Language Pack** и устанавливаем данное расширение на свой ПК ![Рис.1](Image\Рис.1.jpg). После установки расширения необходимо перезагрузить VS Code, после чего вызваем строку поиска сочетанием клавиш **CTRL+Shift+P**. В появившейся строке после символа **>** начинаем набирать слово _Language_. ![Рис.2](Image\Рис.2.jpg). В выпадающем окне выбираем **Configure Display Language**. В открывшемся файле _locale.json_ меняем "en" на "ru" ![Рис.3](Image\Рис.3.jpg). После чего перезагружаем VS Code. Русский язык настроен.


## 4. Работа в Visual Studio Code
Все команды **Git** пишутся имеено в VS Code. Для этого необходимо вызвать **_Терминал_**.
Терминал можно вызвать несколькими способами: В верхнем меню нажимаем **Вид** в появившемся списке выбираем **Терминал** ![Рис.4](Image\Рис.4.jpg), либо вызываем Терминал сочетанием клавиш **Cntrl+`**.

Единовременно можно вызвать сразу несколько терминалов, для этого нужно нажать **_+_**, также можно выбрать модуль, например _Git bash_ или _PowerShell_ ![Рис.5](Image\Рис.5.jpg)

## 5. Настройка **Git**
При первом использовании Git необходимо представиться. Для
этого нужно ввести в терминале 2 команды:
```
git config --global user.name «Ваше имя английскими буквами» 
git config --global user.email ваша почта@example.com
```
## 6. Работа с **Git**. Основные команды **Git**

> Для того, чтобы инициализировать репозиторий необходимо в терминале ввести кманду **git init**

Для работы нам нужно создать в корне папки файл с расширением _.md_ (Markdown). Это можно сделать несколькими способами:

1. в Visual Studio Code рядом с корневой папкой нажимаем иконку "создать файл" ![Рис.6](Image\Рис.6.jpg); 

2. В верхнем меню нажимаем **_Файл_**, в появившемся списке выбираем **_Создать файл_**;

3. Создаёт новый файл сочетанием клавиш **_Cntr+Alt+Windows+N_**;

4. В поле _"Проводник"_ нажимаем правую клавишу мыши, в появившемся списке выбираем **_Создать файл_**.


> После создания файла откроется файл с пронумерованной первой строкой ![Рис.7](Image\Рис.7.jpg). В этом файле прописывается информация, но не команды!

> Чтобы записать изменения в репозиторий, необходимо ввести команду **git add**, после чего указать наименование файла, который записываем. Например, **_git add New_file.md_**. Можно воспомльзоваться командой **_git add ._**, что будет означать "записать всё".

> После записи необходимо создать коммит. Для этого вводим команду **_git commit -m "message"_**, где "message" где будет означать комментарий к коммиту, например **_git commit -m "Дополнили раздел 6"._**

> Команды **git add** и **_git commit -m "message"_** можно объединить командой **_git commit -am "message"_**. Например, **_git commit -am Дополнили раздел 6"._**

> Для того, чтобы проверить индексацию изменений и увидеть, какие файлы не отслеживаются **Git** необходимо воспользоваться командой **_git status_**. Данная команда отображает состояние рабочего каталога и раздела проиндексированных файлов.

> Команда **_git diff_** используется для вычисления разницы между любыми двумя **Git** деревьями. Это может быть, например, разница между вашей рабочей директорией и индексом.

В **Git** есть очень удобные лайфхаки.Для экономии времени с помощью клавиши **_Tab_** можно не набирать наименования файлов, комманд, веток, а набрать первые пару символов, продолжить этой клавишей. Также, если команды ранее вводились, их можно выбирать с помощью стрелочки **_"вверх"_** и **_"вниз"_**. Это позволять сэкономить дракоценное время.

В **Git** нужно постоянно сохраняться, набирая на клавиатуре **_Ctrl+S_**. Для того, чтобы не делать это постонянно, можно в верхней панели нажать **_Файл_** и прожать галочку на пункте **_Автосохранение_**. Таким образом, файл пересохраняется автоматически.

## 7. Работа с ветвлением в **Git**
Так как **Git** разработан для удобной и продуктивной работы сразу нескольких разработчиков, что позволяет не путаться в данных, была придумана система ветвления. По умолчанию существует лишь одна основная ветка. Она называется **_master_** или **_main_**.

> Для того, чтобы создать новую ветку необходимо набрать команду **_git branch_branchname_**, где branchname - это название ветки, которую создаём. Для того, чтобы посмотреть, в какой ветке находимся сейчас, необходимо набрать команду **_git branch_**. необходимая команда будет выделена **_*_**. ![Рис.8](Image\Рис.8.jpg). Также возле наименования папки в скопках указано, в какой ветке мы сейчас находимся.
> Для выбора необходимой ветки нужно вызвать команду **_git checkout branchname_**. В терминале пояится надпись _Switched to branch 'branchname'_, что будет означать, что мы перешли на нужную нам ветку. ![Рис.9](Image\Рис.9.jpg)

> После того, как все необходимые данные в ветке прописаны, записыны и создан коммит, необходимо слить всё в главную ветку **master (main)**. Для этого нужно перейти в ветку **master (main)** и задать комманду **_git merge_branchname_**, где branchname - наименование ветки, которую сливаем с основной веткой, после чего записываем и делаем коммит. ![Рис.10](Image\Рис.10.jpg)
> Иногда при слиянии веток случаются конфликты. Конфликт случаются не потому, что мы что-то сделали не так, а потому что ветка **master (main)** содержала в себе одни данные, а в ветке которой мы работали, мы добавили другие данные. Git попросит нас включиться и помочь ему в ручном режиме разобраться в данном вопросе. В поле, где мы пишем текст появится оба варианта и набор команд, из которых нужно будет выбрать нужную:_"Принять текущее изменение", "Принять входящее изменение", "Принять оба изменения", "Сравнить изменения"._ ![Рис.11](Image\Рис.11.jpg). Так, после выбора нужной команды в поле появятся необходимые данные. После чего нужно не забыть записать и сделать коммит.
> Если после слияния веток ветка, которую сливали больше не нужна, её можно удалить командой **_git branch -d branchname_**. ![Рис.12](Image\Рис.12.jpg)

## 8. Добавление изображений в **Git**
В **Git** есть возможность добавлять изображения. Для этого нужно воспользоваться простой конструкцией восклицательный знак, квадратные скобки, круглые скобки. В квадратных скобках мы пишем, как должна называться наше изображение, если изображение не сможет отображаться,а в круглых - относительный путь.![Рис.13](Image\Рис.13.jpg)    ![Рис.14](Image\Рис.14..jpg).

Сами изображения, которые мы хотим отобразить, необходимо загрузить в корень той же папки, где и лежит наш файл. Относительный путь можно получив, нахав в проводнике на изображение и выбрать **_"Скопировать относительный путь"_**.

## 9. Игнорирование файлов
Для того, чтобы исключить в репозитории из отслежывания определенные папки необходимо создать файл ***.gitignore***. В данном файле мы можем прописать отдельные файлы, папки, которые хотим игнорировать, либо разрешения файло(последние 4 символа вместе с точкой), если таковых у нас много. Напимер, теже самые изображения. В файле ***.gitignore*** с новой строки указываем .jpg, .png ![Рис.15](Image\Рис.15.jpg). На рисунке 15 видно, что те файлы, что мы заигнорировали, подсвечены серым, что означает из игнорирование **Git**, в то время как папка **Merge** подсвечена белым, так как не находится в игнорировании, но стоит нам скопировать относительный путь к ней и довать в файл ***.gitignore***, она сразу станет серой и начнёт игнорироваться как и остальные файлы, добавленные в ***.gitignore***. ![Рис.16](Image\Рис.16.jpg) Это нужно для того,чтобы **Git** не отслеживал "мусорные" файлы, которые отслеживать не нужно. После того, как в файл ***.gitignore*** добавили все игнорируе файлы, его необходимо записать (**_git add .gitignore_**).

## 10. История проекта в **Git**
В течение всего проекта, а также после его завершения можно просмотреть историю проекта. Это часто необходимо для того, чтобы узнать, кто и что сделал, выяснить, откуда появились баги, и отменить изменения, вызвавшие проблемы. Для того, чтобы воспользоваться этими данными, нужна возможность навигации по истории. Это возможно сделать с помощью команды **_git log_**. ![Рис.17](Image\Рис.17.jpg). После ввода данной команды в терминале отобразится вся история с обозначением номера коммита, даты создания и именем создателя. 

## 11. Перемещение между коммитами
**_Git_** позволяет переходить от коммита к коммиту,просматривая те или иные коммиты и данные в них. Для того, чтобы просмотреть мне коммиты, необходимо ввести команду **_git log--oneline_**. После данной команды в терминале появятся все коммиты ![Рис.18](Image\Рис.18.jpg). Переход в коммит задается командой **_git  checkout ......._**,  где вместо точек вводим номер коммита, например, на рис. 18 третий коммит снизу "Добавлены все изменения в раздел 6" соответстует номеру **_2f04019_**. Важно помнить, что для дальнейшей работы НЕОБХОДИМО вернуться в последний коммит. В противном случае, рискует потерять данные, которые будем вносить в наш файл. Для того, чтобы вернуться назад в последний коммит, вводим команду " **_git  checkout master_** ![Рис.19](Image\Рис.19.jpg). О том, что мы вернулись в последний коммит будет свидетельствовать надпись (master) в терминале перед вводом последующей команды.

# Работа с **GitHab**

## 12. Знакомство с **GitHab**. Создание учётной записи

**GitHab** - одна из платформ для обмена, хранения и распространения исходного кода, позволяющаая большому количеству разработчиков работать удалённо. **GitHab** достаточно популярен и используется такими компаниями, как _Microsoft_. Для работы в **GitHab** в первую очередь необходимо зайти на [официальный сайт](https://github.com/) создать новую учётную запись с использованием рабочей электронной почты. На указанную почту придёт письмо с просьбой подтверждения учётной записи и предоставлением кода для подтверждения ![Рис.20](Image\Рис.20.jpg). Обратите внимание, что кнопка **_Open GitHub_** подсвечена зелёным цветом🟢. В **GitHab** все кнопки дальнейших действий подсвечиваются зелёным, что позволяет без особых проблем интуитивно и безошибочно двигаться вперёд. После регистрации в **GitHab** можно настроить свой профиль, поменять аватар, указать различные данные о себе, например команию, где работает, веб-сайт, место жительства, социальные сети, либо просто рассказать о себе.

## 13. Создание удалённого репозитория

**GitHab** позволяет создать удалённый репозиторий на самой платформе. Для этого в верхнем правом углу необходимо нажать кнопку ➕. Эта кнопка есть всегда, вне зависимости от того, в какой части сайта мы находимся.![Рис.21](Image\Рис.21.jpg). После нажатия на кнопку ➕ появится меню, в котором необходимо выбрать первый пункт **_new repository_**, после чего откроется страница, в которой будет необходимо написать наименование создаваемого репозитория.![Рис.22](Image\Рис.22.jpg). Если уже был создан локальный репозиторий на компьютере, то удалённый репозиторий лучше всего назвать также. Допустим, наша инструкция лежит в репозитории под названием **_Git_Education2023_**. Назовём удаленный репозиторий также. При создании удалённого репозитория кроме наименование можно добавить и описание репозитория. Кроме того, **GitHab** позволяет определить, будет ли репозиторий приватный или публичный, позволяет добавить лицензии и файлы **_.gitignore_**, что позволит не тратить время на подбор тех или иных файлов и расширений для игнорирования. Также **GitHab** предложит сразу создать **README file**, то есть текстовый файл, содержащий сведения о проекте. После того, как все параметры введены и выбраны, следует нажать зелёную кнопку **_Create repository_**. Удалённый репозиторий практически создан. Появится страница, описывающая дальнейшие данные. Предложено два варианта :

1. 
```
…or create a new repository on the command line
echo "# Git_Education2023" >> README.md
git init
git add README.md
git commit -m "first commit"
git branch -M main
git remote add origin https://github.com/Anna-Estrina/Git_Education2023.git
git push -u origin main
```

2. 
```
…or push an existing repository from the command line
git remote add origin <URL>
git branch -M main
git push -u origin main
```
Первый вариант предусматривает работу с нуля, то есть, когда ещё ничего не создано ни в удалённом, ни в локальном репозиториях. Иначе говоря, он напоминает, что нужно не забыть инициализироваться, создать первый коммит, создать файл (как раз предлагается создать файл **README**).

Второй вариант позволит привязать удалённый репозиторий к уже созданному локальному репозиторию.

## 14. Связывание локального и удалённого репозитория.
>В первую очередь со страницы удалённого репозитория копируем команду **_git remote add origin <U.R.L.>_**. В данной команде **_origin_** обозначает название пути, следующего за ним (<U.R.L.>).  Теперь наш локальный репозиторий связана с удалённым репозиторий.

>Команда **_git branch -M main_** переименовывает ветку **master** на **main**, так как в **GitHab** основная ветка названа **main**.

>Команда **_git push -u origin main_** отправляет изменения в локальном репозитории в удалённый репозиторий. ![Рис.23](Image\Рис.23.jpg)

Команда **_git remote_** позволяет проверить есть ли связь. Если всё хорошо, после введения данной команды в терминале появится **origin**

Команда **_git remote -v_** позволяет получить более детальную информацию: пути для загрузки **(fetch)** и выгрузки **(push)** изменений.

После данных манипуляций переходим в **GitHab**. После обновления страницы наш локальный репозиторий появляется в удалённом репозитории.